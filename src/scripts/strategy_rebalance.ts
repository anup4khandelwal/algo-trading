import fs from "node:fs/promises";
import dotenv from "dotenv";
import { PostgresPersistence } from "../persistence/postgres_persistence.js";

dotenv.config();

async function main() {
  const databaseUrl = process.env.DATABASE_URL;
  if (!databaseUrl) {
    console.error("STRATEGY_REBALANCE_FAIL: DATABASE_URL is not set");
    process.exitCode = 1;
    return;
  }

  const lookback = Number(process.env.STRATEGY_REPORT_LOOKBACK ?? "200");
  const persistence = new PostgresPersistence(databaseUrl);
  await persistence.init();
  const lots = await persistence.loadClosedTradeLots(lookback);
  if (lots.length < 10) {
    console.log(
      "STRATEGY_REBALANCE: not enough closed trade lots (need >=10) for meaningful tuning"
    );
    return;
  }

  const pnls = lots.map((lot) => (lot.exitPrice - lot.entryPrice) * lot.qty);
  const wins = pnls.filter((p) => p > 0).length;
  const winRate = wins / pnls.length;
  const drawdown = maxDrawdown(pnls);
  const avgWin = avg(pnls.filter((p) => p > 0));
  const avgLoss = Math.abs(avg(pnls.filter((p) => p < 0)));

  const proposed = {
    RISK_PER_TRADE: Number(process.env.RISK_PER_TRADE ?? "0.015"),
    STRATEGY_MIN_RSI: Number(process.env.STRATEGY_MIN_RSI ?? "55"),
    STRATEGY_MIN_VOLUME_RATIO: Number(process.env.STRATEGY_MIN_VOLUME_RATIO ?? "1.2"),
    STRATEGY_MAX_SIGNALS: Number(process.env.STRATEGY_MAX_SIGNALS ?? "5"),
    MAX_EXPOSURE_PER_SYMBOL: Number(process.env.MAX_EXPOSURE_PER_SYMBOL ?? "300000")
  };

  if (drawdown > Math.max(avgWin * 3, avgLoss * 2)) {
    proposed.RISK_PER_TRADE = clamp(round(proposed.RISK_PER_TRADE * 0.85, 4), 0.003, 0.03);
    proposed.MAX_EXPOSURE_PER_SYMBOL = Math.round(proposed.MAX_EXPOSURE_PER_SYMBOL * 0.9);
  }

  if (winRate < 0.4) {
    proposed.STRATEGY_MIN_RSI = clamp(proposed.STRATEGY_MIN_RSI + 2, 45, 75);
    proposed.STRATEGY_MIN_VOLUME_RATIO = clamp(
      round(proposed.STRATEGY_MIN_VOLUME_RATIO + 0.1, 2),
      0.8,
      2.5
    );
    proposed.STRATEGY_MAX_SIGNALS = Math.max(2, proposed.STRATEGY_MAX_SIGNALS - 1);
  } else if (winRate > 0.6 && pnls.length < 40) {
    proposed.STRATEGY_MIN_RSI = clamp(proposed.STRATEGY_MIN_RSI - 1, 45, 75);
    proposed.STRATEGY_MIN_VOLUME_RATIO = clamp(
      round(proposed.STRATEGY_MIN_VOLUME_RATIO - 0.05, 2),
      0.8,
      2.5
    );
    proposed.STRATEGY_MAX_SIGNALS = Math.min(12, proposed.STRATEGY_MAX_SIGNALS + 1);
  }

  const content = [
    "# generated by npm run strategy:rebalance",
    `RISK_PER_TRADE=${proposed.RISK_PER_TRADE}`,
    `STRATEGY_MIN_RSI=${proposed.STRATEGY_MIN_RSI}`,
    `STRATEGY_MIN_VOLUME_RATIO=${proposed.STRATEGY_MIN_VOLUME_RATIO}`,
    `STRATEGY_MAX_SIGNALS=${proposed.STRATEGY_MAX_SIGNALS}`,
    `MAX_EXPOSURE_PER_SYMBOL=${proposed.MAX_EXPOSURE_PER_SYMBOL}`
  ].join("\n");

  await fs.writeFile(".env.recommended", `${content}\n`, "utf-8");

  console.log("=== STRATEGY REBALANCE ===");
  console.log(`closed_lots: ${lots.length}`);
  console.log(`win_rate: ${(winRate * 100).toFixed(2)}%`);
  console.log(`max_drawdown_inr: ${drawdown.toFixed(2)}`);
  console.log("wrote: .env.recommended");
  for (const [k, v] of Object.entries(proposed)) {
    console.log(`  ${k}=${v}`);
  }
}

function clamp(v: number, min: number, max: number) {
  return Math.max(min, Math.min(max, v));
}

function round(v: number, digits: number) {
  const f = 10 ** digits;
  return Math.round(v * f) / f;
}

function avg(values: number[]) {
  if (values.length === 0) {
    return 0;
  }
  return values.reduce((acc, v) => acc + v, 0) / values.length;
}

function maxDrawdown(pnlSeries: number[]): number {
  let equity = 0;
  let peak = 0;
  let maxDd = 0;
  for (const pnl of pnlSeries) {
    equity += pnl;
    peak = Math.max(peak, equity);
    maxDd = Math.max(maxDd, peak - equity);
  }
  return maxDd;
}

await main();
